package me.bossm0n5t3r.advanced.chapter08

import java.lang.reflect.Method
import java.lang.reflect.Proxy

object Exercise05Mocking {
    /**
     * Create a mocking framework that allows you to create mocks of interfaces.
     *
     * The mock should be able to capture method calls and return default values for
     * return types.
     *
     * The mock should also be able to capture method calls and run a provided lambda
     * to return a custom value for the method.
     *
     * The mock should also be able to capture method calls and run a provided lambda
     * to run arbitrary code.
     *
     * Generated by Junie on 04.21.2025
     */
    class MockRegistry {
        private val returnValueMap = mutableMapOf<String, Any?>()
        private val bodyMap = mutableMapOf<String, () -> Any?>()

        // Last captured method key
        @Volatile
        var lastCapturedMethodKey: String? = null
            private set

        // Flag to indicate if we're executing a body
        @Volatile
        private var executingBody = false

        inline fun <reified T> mock(): T {
            val klass = T::class.java

            @Suppress("UNCHECKED_CAST")
            return Proxy.newProxyInstance(
                klass.classLoader,
                arrayOf(klass),
            ) { _, method, args ->
                handleMethodCall(method, args)
            } as T
        }

        fun handleMethodCall(
            method: Method,
            args: Array<Any>?,
        ): Any? {
            val methodName = method.name
            val methodKey =
                if (args == null || args.isEmpty()) {
                    "$methodName()"
                } else {
                    "$methodName(${args.joinToString(",")})"
                }

            // If we're in capture mode, just capture the method key and return a default value
            synchronized(this) {
                if (lastCapturedMethodKey == "") {
                    lastCapturedMethodKey = methodKey
                    // Return a default value based on the return type
                    return getDefaultValue(method.returnType)
                }
            }

            // Check if we have a body for this method
            val body = bodyMap[methodKey]
            if (body != null) {
                // Set the flag to indicate we're executing a body
                val wasExecutingBody = executingBody
                executingBody = true
                try {
                    return body.invoke()
                } finally {
                    // Restore the flag
                    executingBody = wasExecutingBody
                }
            }

            // Check if we have a return value for this method
            val returnValue = returnValueMap[methodKey]
            if (returnValue != null) {
                return returnValue
            }

            // If we're executing a body, we should allow calls to other mocks
            if (executingBody) {
                return getDefaultValue(method.returnType)
            }

            // If not, throw an exception
            throw IllegalStateException("No handler for method $methodKey")
        }

        fun <T> setReturnValue(
            action: () -> T,
            returnValue: T,
        ) {
            val methodKey = captureMethodCall(action)
            returnValueMap[methodKey] = returnValue
        }

        fun <T> setBody(
            action: () -> T,
            body: () -> T,
        ) {
            val methodKey = captureMethodCall(action)
            bodyMap[methodKey] = body
        }

        private fun <T> captureMethodCall(action: () -> T): String {
            synchronized(this) {
                // Set capturing mode
                lastCapturedMethodKey = ""
                try {
                    // Execute the action, but it won't actually run the method
                    // because we're in capture mode
                    action()
                    // Get the captured method key
                    return lastCapturedMethodKey ?: throw IllegalStateException("Failed to capture method call")
                } finally {
                    // Clear capturing mode
                    lastCapturedMethodKey = null
                }
            }
        }

        private fun getDefaultValue(type: Class<*>): Any? =
            when (type) {
                Boolean::class.java, java.lang.Boolean::class.java -> false
                Byte::class.java, java.lang.Byte::class.java -> 0.toByte()
                Short::class.java, java.lang.Short::class.java -> 0.toShort()
                Int::class.java, Integer::class.java -> 0
                Long::class.java, java.lang.Long::class.java -> 0L
                Float::class.java, java.lang.Float::class.java -> 0.0f
                Double::class.java, java.lang.Double::class.java -> 0.0
                Char::class.java, Character::class.java -> '\u0000'
                String::class.java -> ""
                else -> null
            }
    }

    data class User(
        val name: String,
    )

    interface UserRepository {
        fun getUser(userId: String): User?

        fun allUsers(): List<User>
    }

    interface UserService {
        fun getUser(): User
    }
}
